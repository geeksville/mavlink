#!/usr/bin/env python
'''
parse a MAVLink protocol XML file and generate a Squirrel implementation

Copyright Andrew Tridgell 2011
Released under GNU GPL version 3 or later
'''

import sys, textwrap, os
import mavparse, mavtemplate

t = mavtemplate.MAVTemplate()

def generate_preamble(outf, msgs, args, xml):
    print("Generating preamble")
    t.write(outf, """
/*
MAVLink protocol implementation (auto-generated by mavgen.py)
Squirrel/DroneScript version

Generated from: ${FILELIST}

Note: this file has been auto-generated. DO NOT EDIT
*/

const MAVProtocolVersion = "${WIRE_PROTOCOL_VERSION}"

""", {'FILELIST' : ",".join(args),
      'PROTOCOL_MARKER' : xml.protocol_marker,
      'crc_extra' : xml.crc_extra,
      'WIRE_PROTOCOL_VERSION' : xml.wire_protocol_version })

def generate_enums(outf, enums):
    print("Generating enums")
    outf.write("\n// enums\n")
    wrapper = textwrap.TextWrapper(initial_indent="", subsequent_indent="                        // ")
    for e in enums:
        outf.write("\n// %s\n" % e.name)
        
        for entry in e.entry:
            outf.write("const %s = %u // %s\n" % (entry.name, entry.value, wrapper.fill(entry.description)))

def generate_message_ids(outf, msgs):
    print("Generating message IDs")
    outf.write("\n// message IDs\n")
    outf.write("const MAVLINK_MSG_ID_BAD_DATA = -1\n")
    for m in msgs:
        outf.write("const MAVLINK_MSG_ID_%s = %u\n" % (m.name.upper(), m.id))

def generate_classes(outf, msgs):
    print("Generating class definitions")
    wrapper = textwrap.TextWrapper(initial_indent="        ", subsequent_indent="        ")
    for m in msgs:
        outf.write("""
/*
%s
*/
class MAV.%s extends MAV.Message {
    constructor() {
        base.constructor()
        this.messageId = MAVLINK_MSG_ID_%s
    }
""" % (wrapper.fill(m.description.strip()), m.name, m.name.upper()))

        outf.write('    static crcExtra = %s\n' % m.crc_extra)
        if len(m.fieldnames) != 0:
                outf.write('    static fieldNames = ["%s"]\n' % '", "'.join(m.fieldnames))
        outf.write("\n")

        for f in m.fields:
                outf.write("    %s = 0\n" % (f.name))
        outf.write("\n")

        # FIXME - use a more code space efficient encoding?
        outf.write("    function packPayload(b) {\n")
        for f in m.ordered_fields:
            outf.write("        writea(b, %s, '%s', %s)\n" % (f.name, mavfmt(f), f.array_length))
        outf.write("    }\n")
        # FIXME - use crc_extra
        # FIXME - need to init arrays in constructor
        outf.write("    function unpackPayload(b) {\n")
        for f in m.ordered_fields:
            outf.write("        %s = reada(b, '%s', %s)\n" % (f.name, mavfmt(f), f.array_length))
        outf.write("    }\n")
        outf.write("}\n\n")

def mavfmt(field):
    '''work out the struct format for a type'''
    map = {
        'float'    : 'f',
        'double'   : 'd',
        'char'     : 'c',
        'int8_t'   : 'c',
        'uint8_t'  : 'b',
        'uint8_t_mavlink_version'  : 'b',
        'int16_t'  : 's',
        'uint16_t' : 'w',
        'int32_t'  : 'i',
        'uint32_t' : 'i',
        'int64_t'  : 'l',
        'uint64_t' : 'l',
        }

    return map[field.type]

def generate_dispatcher(outf, msgs):
    print("Generating dispatcher")

    for m in msgs:
        outf.write("MAV.Map[MAVLINK_MSG_ID_%s] <- MAV.%s\n" % (
            m.name.upper(), m.name))

def generate_methods(outf, msgs):
    print("Generating methods")

    def field_descriptions(fields):
        ret = ""
        for f in fields:
            ret += "                %-18s        : %s (%s)\n" % (f.name, f.description.strip(), f.type)
        return ret

    wrapper = textwrap.TextWrapper(initial_indent="", subsequent_indent="                ")

    for m in msgs:
        comment = "%s\n\n%s" % (wrapper.fill(m.description.strip()), field_descriptions(m.fields))

        selffieldnames = 'self, '
        for f in m.fields:
            if f.omit_arg:
                selffieldnames += '%s=%s, ' % (f.name, f.const_value)
            else:
                selffieldnames += '%s, ' % f.name
        selffieldnames = selffieldnames[:-2]

        sub = {'NAMELOWER'      : m.name.lower(),
               'SELFFIELDNAMES' : selffieldnames,
               'COMMENT'        : comment,
               'FIELDNAMES'     : ", ".join(m.fieldnames)}

        t.write(outf, """
        def ${NAMELOWER}_encode(${SELFFIELDNAMES}):
                '''
                ${COMMENT}
                '''
                msg = MAVLink_${NAMELOWER}_message(${FIELDNAMES})
                msg.pack(self)
                return msg
            
""", sub)

        t.write(outf, """
        def ${NAMELOWER}_send(${SELFFIELDNAMES}):
                '''
                ${COMMENT}
                '''
                return self.send(self.${NAMELOWER}_encode(${FIELDNAMES}))
            
""", sub)


def generate(basename, xml):
    '''generate complete Squirrel implemenation'''
    if basename.endswith('.nut'):
        filename = basename
    else:
        filename = basename + '.nut'

    msgs = []
    enums = []
    filelist = []
    for x in xml:
        msgs.extend(x.message)
        enums.extend(x.enum)
        filelist.append(os.path.basename(x.filename))

    for m in msgs:
        if xml[0].little_endian:
            m.fmtstr = '<'
        else:
            m.fmtstr = '>'
        #for f in m.ordered_fields:
        #    m.fmtstr += mavfmt(f)
        m.order_map = [ 0 ] * len(m.fieldnames)
        for i in range(0, len(m.fieldnames)):
            m.order_map[i] = m.ordered_fieldnames.index(m.fieldnames[i])

    print("Generating %s" % filename)
    outf = open(filename, "w")
    generate_preamble(outf, msgs, filelist, xml[0])
    generate_enums(outf, enums)
    generate_message_ids(outf, msgs)
    generate_classes(outf, msgs)
    generate_dispatcher(outf, msgs)
    #generate_methods(outf, msgs)
    outf.close()
    print("Generated %s OK" % filename)
